# -*- coding: utf-8 -*-
"""feistel_cypher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A4G0O6F-Kf5gR32TCPrLUkRMbU1_X5QG
"""

import secrets

BLOCK_SIZE = 8
KEY_SIZE = BLOCK_SIZE // 2

def XOR(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def f_function(data_half: bytes, key: bytes) -> bytes:
    return XOR(data_half, key)

def pad_pkcs7(data: bytes, block_size: int) -> bytes:
    padding_len = block_size - (len(data) % block_size)
    padding = bytes([padding_len] * padding_len)
    return data + padding

def unpad_pkcs7(padded_data: bytes) -> bytes:
    if not padded_data:
        raise ValueError("Cannot unpad empty data.")

    padding_len = padded_data[-1]
    if padding_len > len(padded_data):
        raise ValueError("Invalid padding: padding length is larger than data.")

    padding = padded_data[-padding_len:]
    if not all(p == padding_len for p in padding):
        raise ValueError("Invalid padding: incorrect padding bytes.")

    return padded_data[:-padding_len]

def prepare_plaintext(text: str, block_size: int) -> list[bytes]:
    plaintext_bytes = text.encode('utf-8')
    padded_bytes = pad_pkcs7(plaintext_bytes, block_size)
    blocks = [padded_bytes[i:i+block_size] for i in range(0, len(padded_bytes), block_size)]
    return blocks

def encrypt(block: bytes, key1: bytes, key2: bytes) -> bytes:
    half_len = len(block) // 2
    L0, R0 = block[:half_len], block[half_len:]

    L1 = R0
    R1 = XOR(L0, f_function(R0, key1))

    L2 = R1
    R2 = XOR(L1, f_function(R1, key2))

    return L2 + R2

def feistel_encrypt(plaintext: str, key1: bytes, key2: bytes) -> bytes:
    blocks = prepare_plaintext(plaintext, BLOCK_SIZE)
    ciphertext_blocks = []
    for block in blocks:
        encrypted_block = encrypt(block, key1, key2)
        ciphertext_blocks.append(encrypted_block)
    return b''.join(ciphertext_blocks)

def feistel_decrypt(ciphertext: bytes, key1: bytes, key2: bytes) -> str:
    blocks = [ciphertext[i:i+BLOCK_SIZE] for i in range(0, len(ciphertext), BLOCK_SIZE)]
    plaintext_blocks = []
    for block in blocks:
        decrypted_block = encrypt(block, key2, key1)
        plaintext_blocks.append(decrypted_block)

    padded_plaintext = b''.join(plaintext_blocks)
    return unpad_pkcs7(padded_plaintext).decode('utf-8')

def rand_key_gen(size_in_bytes: int) -> bytes:
    return secrets.token_bytes(size_in_bytes)

def get_key(prompt: str, size: int) -> bytes:
    key_str = input(prompt)
    key_bytes = key_str.encode('utf-8')
    return (key_bytes + b'\0' * size)[:size]

def main():
    while True:
        print("\nFeistel Cipher Menu")
        print("1. Encrypt Text")
        print("2. Decrypt Text")
        print("3. Exit")
        choice = input("Enter choice (1/2/3): ")

        if choice == '1':
            plaintext = input("Enter the text to encrypt: ")
            key_choice = input("Use (R)andom keys or (C)ustom keys? ").upper()

            if key_choice == 'R':
                key1 = rand_key_gen(KEY_SIZE)
                key2 = rand_key_gen(KEY_SIZE)
                print(f"Generated Key 1 (hex): {key1.hex()}")
                print(f"Generated Key 2 (hex): {key2.hex()}")
            else:
                key1 = get_key("Enter custom key 1: ", KEY_SIZE)
                key2 = get_key("Enter custom key 2: ", KEY_SIZE)
                print(f"Using Key 1 (hex): {key1.hex()}")
                print(f"Using Key 2 (hex): {key2.hex()}")

            ciphertext = feistel_encrypt(plaintext, key1, key2)
            print(f"\nEncrypted Ciphertext (hex): {ciphertext.hex()}")

        elif choice == '2':
            try:
                hex_ciphertext = input("Enter the ciphertext (in hex): ")
                ciphertext = bytes.fromhex(hex_ciphertext)

                print("Enter encryption keys:")
                key1 = get_key("Enter key 1: ", KEY_SIZE)
                key2 = get_key("Enter key 2: ", KEY_SIZE)

                decrypted_text = feistel_decrypt(ciphertext, key1, key2)
                print(f"\nDecrypted Text: {decrypted_text}")

            except (ValueError, UnicodeDecodeError) as e:
                print(f"Decryption failed. Error: {e}")
                print("This may be due to incorrect keys, invalid ciphertext, or padding errors.")

        elif choice == '3':
            print("Exiting program. Goodbye!")
            break
        else:
            print("Invalid choice. Please enter 1, 2, or 3.")

if __name__ == "__main__":
    main()

